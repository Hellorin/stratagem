// automatically generated by Xtext
grammar ch.unige.cui.smv.stratagem.xtext.TransitionSystemDsl with org.eclipse.xtext.common.Terminals

import "http://cui.unige.ch/smv/transitionsystem.ecore" as ts
import "http://cui.unige.ch/smv/adt.ecore" as adt
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

TransitionSystem returns ts::TransitionSystem:
	'TransitionSystem'
	adt=ADT
	'initialState' '=' initialState=Term
	'Strategies'
	(auxiliary+=Auxiliary)*
	'Transitions'
	(transitions+=Transition)*;

terminal TERMVAR		: '$''^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

Transition returns ts::DeclaredStrategy:
	name=ID
	'='
	body=NonVariableStrategy;

Auxiliary returns ts::DeclaredStrategy:
	name=ID
	( '(' formalParams+=VariableStrategy ("," formalParams+=VariableStrategy)* ')' )? 
	'='
	body=NonVariableStrategy;

Strategy returns ts::Strategy:
	NonVariableStrategy | VariableStrategy
;

NonVariableStrategy returns ts::NonVariableStrategy:
	=> PredefStrats | DeclaredStrategyInstance;

PredefStrats returns ts::NonVariableStrategy:
	Identity | Fail | Choice | Sequence | Fixpoint | IfThenElse | Not | SimpleStrategy | One | Saturation | Union
;

One returns ts::One:
	'One' '(' S=Strategy ',' n=INT ')'
;

DeclaredStrategyInstance returns ts::DeclaredStrategyInstance: 
	{ts::DeclaredStrategyInstance}
	declaration=[ts::DeclaredStrategy]
	'('
	( 	actualParams+=Strategy (','  actualParams+=Strategy )* )? ')'
;


Saturation returns ts::Saturation:
	'Saturation' '(' S=Strategy ',' n=INT ')'
;

IfThenElse returns ts::IfThenElse:
	'IfThenElse' '(' S1=Strategy ',' S2=Strategy ',' S3=Strategy')'
;

SimpleStrategy returns ts::SimpleStrategy: 
	'{' equations+=RewriteRule (',' equations+=RewriteRule)* '}'
;


Not returns ts::Not:
	'Not' '(' S=(SimpleStrategy | DeclaredStrategyInstance | VariableStrategy) ')'
;

Fixpoint returns ts::FixPointStrategy:
	'Fixpoint' '(' S=Strategy ')'
;

Choice returns ts::Choice:
	'Choice' '(' S1=Strategy ',' S2=Strategy ')'
;

Union returns ts::Union:
	'Union' '(' S1=Strategy ',' S2=Strategy ')'
;

Sequence returns ts::Sequence:
	'Sequence' '(' S1=Strategy ',' S2=Strategy ')'
;

Identity returns ts::Identity:
	'Identity' {ts::Identity};
	
Fail returns ts::Fail:
	'Fail' {ts::Fail}
;

VariableStrategy returns ts::VariableStrategy:
	name=ID;

ATerm returns adt::ATerm:
	Term | Variable
	;

ASort returns adt::ASort:
	SubSort | Sort;

ADT returns adt::ADT:
	'ADT'
	name=ID
	'Signature' signature=Signature
	(=> 'Axioms' equations+=Equation (equations+=Equation)*)?
	(=> 'Variables' variables+=VariableDeclaration (variables+=VariableDeclaration)*)?;

Signature returns adt::Signature:
	'Sorts' sorts+=ASort ("," sorts+=ASort)*
	(=> 'Generators' generators+=Operation (generators+=Operation)*)
	(=> 'Operations' operations+=Operation (operations+=Operation)*)?;

VariableDeclaration returns adt::VariableDeclaration:
	name=ID
	':'
	sort=[adt::ASort];

Equation returns adt::Equation:
	leftHandTerm=ATerm '='
	rightHandTerm=ATerm;

RewriteRule returns adt::Equation:
	leftHandTerm=ATerm '->'
	rightHandTerm=ATerm;

SubSort returns adt::SubSort:
	name=ID
	'<'
	superSort=[adt::ASort];

Sort returns adt::Sort:
	{adt::Sort}
	name=ID;

Term returns adt::Term:
	{adt::Term}
	operationSymbol=[adt::Operation]
	('(' subterms+=ATerm ("," subterms+=ATerm)* ')')?;

Variable returns adt::Variable:
	{adt::Variable}
	declaration=[adt::VariableDeclaration|TERMVAR];

Operation returns adt::Operation:
	name=ID
	':'
	(formalParameters+=[adt::ASort] ("," formalParameters+=[adt::ASort])* '->')?
	returnType=[adt::ASort];
